#This mod will show your level of strength.
#Developer's telegram @ZZZOOOVVV2007
#‚†Ñ‚£ø‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚£ø‚£ø‚£ø
#‚†Ñ‚£ø‚£ø‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚£ø‚†Ñ‚†Ñ‚£ø
#‚£ø‚†Ñ‚†Ñ‚£ø‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚£ø‚†Ñ‚†Ñ‚†Ñ‚£ø
#‚£ø‚†Ñ‚†Ñ‚†Ñ‚£ø‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚£ø‚†Ñ‚†Ñ‚†Ñ‚£ø
#‚£ø‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚£ø‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚£ø‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø
#‚£ø‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚£ø‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚£ø‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚£ø‚£ø
#‚£ø‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚£ø‚£ø‚£ø‚†Ñ‚†Ñ‚£ø‚†Ñ‚£ø‚£ø‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø
#‚£ø‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚£ø‚†Ñ‚†Ñ‚†Ñ‚£ø‚£ø‚†Ñ‚£ø‚£ø‚£ø‚£ø‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚£ø‚£ø‚£ø‚£ø
#‚†Ñ‚£ø‚†Ñ‚†Ñ‚†Ñ‚£ø‚†Ñ‚†Ñ‚†Ñ‚£ø‚£ø‚†Ñ‚†Ñ‚†Ñ‚£ø‚£ø‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø
#‚†Ñ‚†Ñ‚£ø‚†Ñ‚†Ñ‚£ø‚†Ñ‚†Ñ‚£ø‚†Ñ‚†Ñ‚†Ñ‚£ø‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚£ø‚†Ñ‚†Ñ‚†Ñ‚£ø‚£ø‚£ø‚£ø‚†Ñ‚£ø
#‚†Ñ‚†Ñ‚†Ñ‚£ø‚†Ñ‚£ø‚†Ñ‚£ø‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚£ø‚£ø‚£ø‚£ø‚†Ñ‚£ø
#‚£ø‚£ø‚£ø‚†Ñ‚†Ñ‚£ø‚£ø‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚£ø‚£ø‚£ø‚£ø‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚£ø
#‚£ø‚†Ñ‚†Ñ‚†Ñ‚£ø‚†Ñ‚†Ñ‚£ø‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚£ø‚£ø‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚£ø‚†Ñ‚†Ñ‚£ø
#‚†Ñ‚£ø‚†Ñ‚†Ñ‚†Ñ‚£ø‚†Ñ‚£ø‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚£ø
#‚†Ñ‚†Ñ‚£ø‚†Ñ‚†Ñ‚£ø‚†Ñ‚£ø‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚£ø‚£ø
#‚†Ñ‚†Ñ‚†Ñ‚£ø‚†Ñ‚£ø‚£ø‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚£ø‚£ø
#‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚£ø‚£ø‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚£ø‚£ø‚†Ñ‚†Ñ‚†Ñ‚£ø
#‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚£ø‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚£ø‚†Ñ‚†Ñ‚£ø‚†Ñ‚†Ñ‚†Ñ‚£ø
#‚†Ñ‚†Ñ‚†Ñ‚£ø‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚£ø‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚£ø‚£ø‚£ø‚£ø
#‚†Ñ‚†Ñ‚£ø‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚£ø
#‚†Ñ‚†Ñ‚£ø‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚£ø
#‚†Ñ‚†Ñ‚£ø‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚£ø
#‚†Ñ‚†Ñ‚†Ñ‚£ø‚†Ñ‚†Ñ‚£ø‚£ø‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚£ø‚£ø‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚£ø
#‚†Ñ‚†Ñ‚£ø‚£ø‚£ø‚£ø‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø

import datetime
import os
import logging
import json
import csv
import zipfile
import shutil
import sqlite3
import xml.etree.ElementTree as ET
import yaml
from fpdf import FPDF
import openpyxl
from hikkatl.tl.types import Message
from hikkatl.tl.functions.messages import GetHistoryRequest
from .. import loader, utils

logging.basicConfig(
    filename="logdon_actions.log",
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s",
)

@loader.tds
class LogDonModule(loader.Module):
    strings = {
        "name": "LogDon",
        "saved": "‚òëÔ∏è",
        "no_messages": "üö´ –ù–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–π –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è.",
        "media_not_supported": "üö´ –ú–µ–¥–∏–∞—Ñ–∞–π–ª –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è.",
        "progress": "‚è≥ –°–æ—Ö—Ä–∞–Ω–µ–Ω–æ {current}/{total} —Å–æ–æ–±—â–µ–Ω–∏–π...",
        "json_export": "üìÅ –õ–æ–≥ —Å–æ—Ö—Ä–∞–Ω–µ–Ω –≤ —Ñ–æ—Ä–º–∞—Ç–µ JSON.",
        "html_export": "üìÅ –õ–æ–≥ —Å–æ—Ö—Ä–∞–Ω–µ–Ω –≤ —Ñ–æ—Ä–º–∞—Ç–µ HTML.",
        "md_export": "üìÅ –õ–æ–≥ —Å–æ—Ö—Ä–∞–Ω–µ–Ω –≤ —Ñ–æ—Ä–º–∞—Ç–µ Markdown.",
        "csv_export": "üìÅ –õ–æ–≥ —Å–æ—Ö—Ä–∞–Ω–µ–Ω –≤ —Ñ–æ—Ä–º–∞—Ç–µ CSV.",
        "pdf_export": "üìÅ –õ–æ–≥ —Å–æ—Ö—Ä–∞–Ω–µ–Ω –≤ —Ñ–æ—Ä–º–∞—Ç–µ PDF.",
        "xlsx_export": "üìÅ –õ–æ–≥ —Å–æ—Ö—Ä–∞–Ω–µ–Ω –≤ —Ñ–æ—Ä–º–∞—Ç–µ Excel.",
        "sqlite_export": "üìÅ –õ–æ–≥ —Å–æ—Ö—Ä–∞–Ω–µ–Ω –≤ —Ñ–æ—Ä–º–∞—Ç–µ SQLite.",
        "xml_export": "üìÅ –õ–æ–≥ —Å–æ—Ö—Ä–∞–Ω–µ–Ω –≤ —Ñ–æ—Ä–º–∞—Ç–µ XML.",
        "yaml_export": "üìÅ –õ–æ–≥ —Å–æ—Ö—Ä–∞–Ω–µ–Ω –≤ —Ñ–æ—Ä–º–∞—Ç–µ YAML.",
        "zip_created": "üì¶ –õ–æ–≥–∏ –∞—Ä—Ö–∏–≤–∏—Ä–æ–≤–∞–Ω—ã –≤ ZIP-—Ñ–∞–π–ª.",
        "cleaned": "üßπ –£–¥–∞–ª–µ–Ω—ã —Å—Ç–∞—Ä—ã–µ –ª–æ–≥–∏ (—Å—Ç–∞—Ä—à–µ 7 –¥–Ω–µ–π).",
        "completed": "‚úÖ –ó–∞–¥–∞—á–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞. –°–æ—Ö—Ä–∞–Ω–µ–Ω–æ {count} —Å–æ–æ–±—â–µ–Ω–∏–π.",
    }

    async def client_ready(self, client, db):
        self.client = client
        self.db = db

    async def _get_chat_name(self, chat):
        try:
            return chat.title if hasattr(chat, "title") else "Private Chat"
        except Exception as e:
            logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –Ω–∞–∑–≤–∞–Ω–∏—è —á–∞—Ç–∞: {e}")
            return "Unknown Chat"

    async def _format_message(self, msg):
        try:
            user_id = msg.sender_id
            date = msg.date.strftime("%d %b. %Y –≤ %H:%M")
            text = msg.raw_text or ""

            media_info = ""
            if msg.media:
                if hasattr(msg.media, "document"):
                    media_info = f"\nüìÑ –ú–µ–¥–∏–∞—Ñ–∞–π–ª: {msg.media.document.mime_type}"
                elif hasattr(msg.media, "photo"):
                    media_info = "\nüì∑ –§–æ—Ç–æ"
                else:
                    media_info = f"\n{self.strings('media_not_supported')}"

            return f"User id: tg://user?id={user_id}, [{date}]\n{text}{media_info}\n\n"
        except Exception as e:
            logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–∏ —Å–æ–æ–±—â–µ–Ω–∏—è: {e}")
            return ""

    async def _save_media(self, msg, media_folder):
        try:
            if msg.media:
                if hasattr(msg.media, "document"):
                    file_name = f"{msg.id}_{msg.media.document.id}.bin"
                    file_path = os.path.join(media_folder, file_name)
                    await msg.download_media(file=file_path)
                    return file_name
            return None
        except Exception as e:
            logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ –º–µ–¥–∏–∞—Ñ–∞–π–ª–∞: {e}")
            return None

    async def _create_zip(self, files, zip_name):
        try:
            with zipfile.ZipFile(zip_name, "w") as zipf:
                for file in files:
                    zipf.write(file, os.path.basename(file))
            return True
        except Exception as e:
            logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ ZIP-–∞—Ä—Ö–∏–≤–∞: {e}")
            return False

    async def _clean_old_logs(self):
        try:
            now = datetime.datetime.now()
            for file in os.listdir("."):
                if file.startswith("logdon_") and (file.endswith(".txt") or file.endswith(".json") or file.endswith(".html") or file.endswith(".md") or file.endswith(".csv") or file.endswith(".pdf") or file.endswith(".xlsx")):
                    file_time = datetime.datetime.fromtimestamp(os.path.getctime(file))
                    if (now - file_time).days > 7:
                        os.remove(file)
            logging.info("–°—Ç–∞—Ä—ã–µ –ª–æ–≥–∏ —É–¥–∞–ª–µ–Ω—ã.")
            await self.client.send_message("me", self.strings("cleaned"))
        except Exception as e:
            logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ —Å—Ç–∞—Ä—ã—Ö –ª–æ–≥–æ–≤: {e}")

    async def _export_to_html(self, messages, filename):
        try:
            html_content = "<html><body><h1>LogDon Export</h1><ul>"
            for msg in messages:
                html_content += f"<li><b>User ID:</b> {msg.sender_id}, <b>Date:</b> {msg.date.strftime('%d %b. %Y –≤ %H:%M')}<br>{msg.raw_text}</li>"
            html_content += "</ul></body></html>"
            with open(filename, "w", encoding="utf-8") as file:
                file.write(html_content)
            return True
        except Exception as e:
            logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —ç–∫—Å–ø–æ—Ä—Ç–µ –≤ HTML: {e}")
            return False

    async def _export_to_md(self, messages, filename):
        try:
            md_content = "# LogDon Export\n\n"
            for msg in messages:
                md_content += f"**User ID:** {msg.sender_id}, **Date:** {msg.date.strftime('%d %b. %Y –≤ %H:%M')}\n{msg.raw_text}\n\n"
            with open(filename, "w", encoding="utf-8") as file:
                file.write(md_content)
            return True
        except Exception as e:
            logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —ç–∫—Å–ø–æ—Ä—Ç–µ –≤ Markdown: {e}")
            return False

    async def _export_to_csv(self, messages, filename):
        try:
            with open(filename, "w", encoding="utf-8", newline="") as file:
                writer = csv.writer(file)
                writer.writerow(["User ID", "Date", "Message"])
                for msg in messages:
                    writer.writerow([msg.sender_id, msg.date.strftime('%d %b. %Y –≤ %H:%M'), msg.raw_text])
            return True
        except Exception as e:
            logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —ç–∫—Å–ø–æ—Ä—Ç–µ –≤ CSV: {e}")
            return False

    async def _export_to_pdf(self, messages, filename):
        try:
            pdf = FPDF()
            pdf.add_page()
            pdf.set_font("Arial", size=12)
            for msg in messages:
                pdf.cell(200, 10, txt=f"User ID: {msg.sender_id}, Date: {msg.date.strftime('%d %b. %Y –≤ %H:%M')}", ln=True)
                pdf.multi_cell(0, 10, txt=msg.raw_text)
                pdf.ln()
            pdf.output(filename)
            return True
        except Exception as e:
            logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —ç–∫—Å–ø–æ—Ä—Ç–µ –≤ PDF: {e}")
            return False

    async def _export_to_xlsx(self, messages, filename):
        try:
            wb = openpyxl.Workbook()
            ws = wb.active
            ws.title = "LogDon Export"
            ws.append(["User ID", "Date", "Message"])
            for msg in messages:
                ws.append([msg.sender_id, msg.date.strftime('%d %b. %Y –≤ %H:%M'), msg.raw_text])
            wb.save(filename)
            return True
        except Exception as e:
            logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —ç–∫—Å–ø–æ—Ä—Ç–µ –≤ Excel: {e}")
            return False

    async def _export_to_sqlite(self, messages, filename):
        try:
            conn = sqlite3.connect(filename)
            cursor = conn.cursor()
            cursor.execute("CREATE TABLE IF NOT EXISTS logs (user_id INTEGER, date TEXT, message TEXT)")
            for msg in messages:
                cursor.execute("INSERT INTO logs (user_id, date, message) VALUES (?, ?, ?)", (msg.sender_id, msg.date.strftime('%d %b. %Y –≤ %H:%M'), msg.raw_text))
            conn.commit()
            conn.close()
            return True
        except Exception as e:
            logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —ç–∫—Å–ø–æ—Ä—Ç–µ –≤ SQLite: {e}")
            return False

    async def _export_to_xml(self, messages, filename):
        try:
            root = ET.Element("logs")
            for msg in messages:
                log_entry = ET.SubElement(root, "log")
                ET.SubElement(log_entry, "user_id").text = str(msg.sender_id)
                ET.SubElement(log_entry, "date").text = msg.date.strftime('%d %b. %Y –≤ %H:%M')
                ET.SubElement(log_entry, "message").text = msg.raw_text
            tree = ET.ElementTree(root)
            tree.write(filename, encoding="utf-8", xml_declaration=True)
            return True
        except Exception as e:
            logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —ç–∫—Å–ø–æ—Ä—Ç–µ –≤ XML: {e}")
            return False

    async def _export_to_yaml(self, messages, filename):
        try:
            log_data = [{"user_id": msg.sender_id, "date": msg.date.strftime('%d %b. %Y –≤ %H:%M'), "message": msg.raw_text} for msg in messages]
            with open(filename, "w", encoding="utf-8") as file:
                yaml.dump(log_data, file, allow_unicode=True)
            return True
        except Exception as e:
            logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —ç–∫—Å–ø–æ—Ä—Ç–µ –≤ YAML: {e}")
            return False

    @loader.command(ru_doc="<—á–∏—Å–ª–æ> [–∫–ª—é—á–µ–≤–æ–µ_—Å–ª–æ–≤–æ|json|html|md|csv|pdf|xlsx|sqlite|xml|yaml] - –°–æ—Ö—Ä–∞–Ω–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏—è –≤ —Ñ–∞–π–ª")
    async def ldcmd(self, message: Message):
        args = utils.get_args(message)
        if not args or not args[0].isdigit():
            await utils.answer(message, "üö´ –£–∫–∞–∂–∏—Ç–µ —á–∏—Å–ª–æ —Å–æ–æ–±—â–µ–Ω–∏–π –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è.")
            return

        limit = int(args[0])
        if limit <= 0:
            await utils.answer(message, "üö´ –ß–∏—Å–ª–æ —Å–æ–æ–±—â–µ–Ω–∏–π –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –±–æ–ª—å—à–µ 0.")
            return

        keyword = args[1] if len(args) > 1 and not args[1].lower() in ["json", "html", "md", "csv", "pdf", "xlsx", "sqlite", "xml", "yaml"] else None
        export_format = args[1].lower() if len(args) > 1 and args[1].lower() in ["json", "html", "md", "csv", "pdf", "xlsx", "sqlite", "xml", "yaml"] else "txt"

        chat = await message.get_chat()
        all_messages = []
        offset_id = 0
        total_count = 0

        while True:
            try:
                history = await self.client(GetHistoryRequest(
                    peer=chat,
                    limit=min(100, limit - total_count),
                    offset_id=offset_id,
                    offset_date=None,
                    add_offset=0,
                    max_id=0,
                    min_id=0,
                    hash=0
                ))

                if not history.messages:
                    break

                if keyword:
                    filtered_messages = [msg for msg in history.messages if keyword.lower() in (msg.raw_text or "").lower()]
                    all_messages.extend(filtered_messages)
                else:
                    all_messages.extend(history.messages)

                total_count += len(history.messages)
                if total_count >= limit:
                    break

                offset_id = history.messages[-1].id

                if total_count % 10 == 0:
                    await utils.answer(message, self.strings("progress").format(current=total_count, total=limit))
            except Exception as e:
                logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –∏—Å—Ç–æ—Ä–∏–∏ —Å–æ–æ–±—â–µ–Ω–∏–π: {e}")
                break

        if not all_messages:
            await utils.answer(message, self.strings("no_messages"))
            return

        media_folder = "logdon_media"
        os.makedirs(media_folder, exist_ok=True)

        log_content = []
        for msg in reversed(all_messages):
            formatted_msg = await self._format_message(msg)
            media_file = await self._save_media(msg, media_folder)
            if media_file:
                formatted_msg += f"üìÅ –ú–µ–¥–∏–∞—Ñ–∞–π–ª: {media_file}\n"
            log_content.append(formatted_msg)

        filename = f"logdon_{chat.id}_{datetime.datetime.now().strftime('%Y%m%d_%H%M%S')}"
        if export_format == "json":
            log_data = [{"user_id": msg.sender_id, "date": msg.date.strftime("%d %b. %Y –≤ %H:%M"), "message": msg.raw_text} for msg in reversed(all_messages)]
            filename += ".json"
            with open(filename, "w", encoding="utf-8") as file:
                json.dump(log_data, file, ensure_ascii=False, indent=4)
            await utils.answer(message, self.strings("json_export"))
        elif export_format == "html":
            filename += ".html"
            if await self._export_to_html(reversed(all_messages), filename):
                await utils.answer(message, self.strings("html_export"))
        elif export_format == "md":
            filename += ".md"
            if await self._export_to_md(reversed(all_messages), filename):
                await utils.answer(message, self.strings("md_export"))
        elif export_format == "csv":
            filename += ".csv"
            if await self._export_to_csv(reversed(all_messages), filename):
                await utils.answer(message, self.strings("csv_export"))
        elif export_format == "pdf":
            filename += ".pdf"
            if await self._export_to_pdf(reversed(all_messages), filename):
                await utils.answer(message, self.strings("pdf_export"))
        elif export_format == "xlsx":
            filename += ".xlsx"
            if await self._export_to_xlsx(reversed(all_messages), filename):
                await utils.answer(message, self.strings("xlsx_export"))
        elif export_format == "sqlite":
            filename += ".db"
            if await self._export_to_sqlite(reversed(all_messages), filename):
                await utils.answer(message, self.strings("sqlite_export"))
        elif export_format == "xml":
            filename += ".xml"
            if await self._export_to_xml(reversed(all_messages), filename):
                await utils.answer(message, self.strings("xml_export"))
        elif export_format == "yaml":
            filename += ".yaml"
            if await self._export_to_yaml(reversed(all_messages), filename):
                await utils.answer(message, self.strings("yaml_export"))
        else:
            filename += ".txt"
            with open(filename, "w", encoding="utf-8") as file:
                file.writelines(log_content)

        if os.path.getsize(filename) > 5 * 1024 * 1024:
            zip_name = f"{filename}.zip"
            if await self._create_zip([filename] + [os.path.join(media_folder, f) for f in os.listdir(media_folder)], zip_name):
                await self.client.send_file("me", zip_name, caption=self.strings("zip_created"))
                os.remove(zip_name)
            else:
                await self.client.send_file("me", filename, caption="–õ–æ–≥ —Å–æ—Ö—Ä–∞–Ω–µ–Ω.")
        else:
            await self.client.send_file("me", filename, caption="–õ–æ–≥ —Å–æ—Ö—Ä–∞–Ω–µ–Ω.")

        os.remove(filename)
        for file in os.listdir(media_folder):
            os.remove(os.path.join(media_folder, file))
        os.rmdir(media_folder)

        await self._clean_old_logs()

        await utils.answer(message, self.strings("completed").format(count=len(all_messages)))
